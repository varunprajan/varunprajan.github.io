<!DOCTYPE html>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>A random walk down Wall Street | Varun&#39;s blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="A random walk down Wall Street" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction I was lucky enough to receive an offer from a tech company recently, and, as part of that offer, a substantial equity package. This company allows you to choose your own mix of equity. The equity package can be allocated across four asset types: cash, restricted stock units (RSUs), and two types of options, one aggressive (&quot;at the money&quot;, or ATM) and the other very aggressive (&quot;out of the money&quot;, OTM). The value of the equity package, for the non-cash asset types, depends on how the stock price evolves during one&#39;s tenure. If the stock price increases greatly, the OTM and ATM options are superior to RSUs, which in turn is superior to cash. If the stock price drops, the ranking is reversed. While the HR department provided a helpful guide to understand the mechanics of each asset type, and informed me that, if I couldn&#39;t make a decision, I would be opted-in to a mix of 75% RSUs and 25% ATM options, I wanted to understand the value of this package in greater detail. (The term &quot;value&quot; is ill-defined, and I&#39;ll return to it later.) I decided to tackle this problem using simulation. The system being modeled can be divided into a few pieces: the actor (me), the equity package, and the stock price. Some of these, like the stock price, evolve endogenously, according to their own mechanics. (Presumably, I am a small enough actor that, while the stock price affects my decisions, like whether/when to exercise, my decisions do not affect the stock price.) Typically, these mechanics will be parametrized by random variables. For instance, as I&#39;ll discuss below, we can assume the stock price changes according to a &quot;geometric Brownian motion&quot; process in which there is a long-term, deterministic trend (parametrized by $\mu$) and short-term, stochastic volatility (parametrized by $\sigma$). I do not know the true values of $\mu$ or $\sigma$, and, if I did, I would be a retired multimillionaire instead of a humble blogpost writer. Instead, I have a rough idea of what reasonable values these parameters might take, based both on historical data as well as my knowledge of trends in the broader market. Running the simulation involves stepping from time $t$ to time $t+1$, and repeating this process $N$ times. What happens during each step? The stock price changes according to the mathematical model. Some of my equity vests. If that equity represents RSUs, I have a decision of whether or not to sell it immediately, or to hold it. And, if that equity represents options, I can choose to exercise and sell immediately, exercise and hold, or not exercise at all. The range of possibilities is actually quite daunting, and expands geometrically with each time increment. In what follows, I will make some (grossly) simplifying assumptions, but, in general, if we want to determine the actor&#39;s optimal decision over a range of simulations/scenarios, we need to optimize over the entire space of his/her decisions. In this example, that means optimizing both for the initial allocation decision --- what fraction of cash, RSUs, and options to choose --- and for the decision about exercising and selling at each time step. How does the &quot;optimization&quot; actually happen? This is actually quite complicated! One plausible approach, although by no means the only one, is to take the results of each simulation and assign a &quot;utility&quot; to each. I would have a function, $U(M_i)$, that describes my utility, $U$, corresponding to the money, $M_i$, generated from simulation $i$. This curve should be monotonically increasing, but need not be linear. Presumably my utility from making \$100k is not 10 times as much as making \$10k; there are diminishing returns to money. Then, the decision would be made on the basis of the actor&#39;s actions that maximize this expected utility. (This field of study is known as &quot;Decision Theory&quot;, if you&#39;d like to read more.) To try to summarize, the following is a generic approach to &quot;Monte Carlo&quot; simulation-based decision making. Model the system mathematically, which means formulating an equation that describes the evolution of the system from time $t$ to $t+1$. The model will possess parameters that govern the system dynamics. Try to formulate a (multivariate) prior distribution for these parameters. Create a set of possibilities for rulesets that the actor in the simulation will follow. Arbitrarily assign the actor a single ruleset based on the possibilities enumerated above. Randomly draw a sample from the prior distribution. Run the simulation with these sampled parameters and the chosen actor ruleset. The simulation will involve repeatedly stepping through time. Store the results and use our function $U$ to compute the associated utility of the &quot;possible future&quot; that we have simulated. Repeat steps 5-6 sufficient times that we have confidence in our estimate of the expected value of utility for the actor ruleset being considered. This is known as the &quot;Monte Carlo&quot; approach. Note that this step can be very expensive, depending on how long it takes for each simulation to run, and how many simulations are required to reach &quot;convergence&quot;. Repeat steps 5-7 for all possible actor rulesets. Maximize the expected utility with respect to the ruleset. Presumably, this is the ruleset we want to follow in practice. Of course, this recommendation is only as good as the assumptions that underpin it: the simplifications made in the mathematical model, the correctness of the prior distribution, the comprehensiveness of the possibilities for rulesets, etc. All of this is somewhat abstract, so let&#39;s use my actual example to make these concepts more concrete. Case study Mathematical model As mentioned above, there are three pieces here: the actor (me), the equity package, and the stock price. The dynamics of the equity package are fairly simple. Excluding some minor details like the &quot;equity cliff&quot;, at each timestep, a fraction 1/N of the equity vests. For instance, if the equity package is \$24k, and, assuming a 4 year vesting schedule, each month \$500 will vest. How this vesting translates into real money (and, in turn how that real money translates into &quot;utility&quot;) is more complicated, and will be discussed later. The stock price is assumed to follow a &quot;Geometric Brownian Motion&quot; model. This essentially decomposes the rate of return into two parts, one deterministic ($\mu$) and one stochastic ($\sigma$). The former describes how the stock price would evolve in the absence of volatility (the &quot;drift&quot;), and the latter accounts for the volatility. Because one of these terms describes a stochastic process, different simulations with the same set of parameters ($\mu$, $\sigma$) will give different results. The governing equation is: $$ S_t / S_{t-1} = \exp(\mu - \sigma^2/2 + \sigma N(0, 1)) $$ where $S_{t}$ is the stock price at time $t$, and $N(0, 1)$ is a unit normal distribution. (Important note: I do not work in finance, and I am certainly not an expert in financial modeling. I chose this model because it seemed widely used and reasonably tractable, but the assumptions of constant variance and Gaussian processes are known to be dubious, and I&#39;m including this caveat so that Nassim Taleb doesn&#39;t yell at me.) Actor&#39;s rulesets There are two main decisons the actor makes. At $t = 0$, the actor decides how to allocate his/her equity across the four asset types: cash, RSUs, ATM options, and OTM options. Then, at each $t &gt; 0$, the actor decides what to do with the equity that has vested. Let&#39;s cover each in turn. Cash is very simple. Equity of amount $M_t$ vests at $t$, and the actor receives a &quot;payout&quot; of $0.9M_t$ in their bank account. (Note: The 0.9 factor is apparently related to tax reasons for the company. I am also ignoring taxation for the individual, which is a very big oversight, and, as a consequence, the numerical results below should not be taken as accurate. That being said, given the actor rulesets under consideration, the taxation of cash and RSUs is similar, so this effect is mostly irrelevant if options are not part of the allocation.) RSUs are also fairly simple. At each time $t$, the actor receives a number of shares equal to $M_t / S_0$: i.e, the nominal value of the equity is divided by the stock price at the grant date, not at the vesting date. So, the actual value of these shares is $M_t * S_{t} / S_{0}$: the shares are worth more than cash (ignoring the discounting factor of 0.9) if the stock appreciates, and the shares are worth less if the opposite is true. I will assume that the actor is conservative, and will sell the RSUs immediately after vesting. (This is not as stupid as it sounds: because RSUs are taxed on vesting, there is no real tax benefit to delaying the sale, and one can hedge against the company&#39;s stock by investing the proceeds into an index fund. In other words, we can imagine two scenarios: one in which we sell the shares and reinvest the same amount in the company (which is equivalent to holding); the other where we sell the shares and reinvest them in a diversified financial product. If the actor was given separate money for this, he/she would invariably choose the second option. So why should it be different if the actor is given money in the form of RSUs?) Options are somewhat more complicated. Here I will make the somewhat questionable assumption that options are exercised at the end of the time period under consideration, with the caveat that they are not exercised if they are worthless. For ATM options, options are worth something if $S_{t} &gt; S_{0}$: the stock has to appreciate. For OTM options, options are worth something only if $S_{t} &gt; 1.5S_{0}$: the stock has to appreciate by at least 50%. To justify this extra risk relative to RSUs, 4 times as many ATM options are given as RSUs for a given equity amount, and the corresponding ratio is 8 for OTM options. The payouts end up being $4 (M / S_0) \max(S_{t_{end}} - S_0, 0)$ for ATM, and $8 (M / S_0) \max(S_{t_{end}} - 1.5 S_0, 0)$ for OTM, where $M$ is the total amount of equity (so, $NM_t$, where $N$ is the number of time steps). Other rulesets are possible for options. The disadvantage of the one under consideration is that the tax bill will be enormous if the options are worth a significant amount, since the gains are concentrated in a single year instead of being more spread out. We can also imagine immediate exercise (which probably doesn&#39;t make sense, especially for OTM options), and exercise as soon as the options are worth a certain amount. These are more complicated to model, however. For the initial allocation decision, I will assume a few different possibilities, summarized in the table below: Python code The python code to run the simulation and model the payouts is presented below. The version I present is vectorized, which makes the computation faster but also perhaps less readable. Note that, in general, it&#39;s easier to program these simulations step-by-step (advancing from $t$ to $t+1$), but this may less computationally efficient. import numpy as np class SimulationRunnerVectorized: def init(self, mu, sigma, n_steps, allocation, price=1): &quot;&quot;&quot; Initialize using parameters (mu, sigma), actor rulesets (allocation), and number of timesteps. The initial stock price can be set to 1 without loss of generality &quot;&quot;&quot; self.mu = mu self.sigma = sigma self.n_steps = n_steps self.grant_price = price self.price = price self.allocation = { equity_type: np.ones(n_steps, ) * amount for equity_type, amount in allocation.items() } &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compute_prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Compute stock prices for all timesteps&quot;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rate_of_return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sigma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cumprod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rate_of_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Run simulation: compute stock prices given initial allocation; compute final payouts&quot;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute_prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payouts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate_payout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grant_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grant_price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payouts&lt;/span&gt; Here is the code for calculating the payouts from the simulation results from typing import Callable, Dict import numpy as np def calculate_payout(prices: np.array, grant_price: float, allocation: Dict[str, Callable]) -&gt; float: &quot;&quot;&quot;Calculate payout by aggregating over all equity types&quot;&quot;&quot; payout = 0 payout_funcs = { &quot;cash&quot;: payout_cash, &quot;rsus&quot;: payout_rsus, &quot;atm_options&quot;: payout_atm_options, &quot;otm_options&quot;: payout_otm_options, } for equity_type, amount in allocation.items(): payout += payout_funcs[equity_type](prices, grant_price, amount=amount) return payout def payout_cash(prices: np.array, grant_price: float, amount: float, discount: float=0.1) -&gt; float: return amount * (1 - discount) def payout_rsus(prices: np.array, grant_price: float, amount: float): n_shares = (amount / grant_price) return n_shares * prices def payout_atm_options(prices: np.array, grant_price: float, amount: float, immediate_exercise: bool=False) -&gt; float: n_options = (amount / grant_price) 4 if immediate_exercise: # this possibility is not considered in the blog post, but is included for illustration return n_options np.maximum(current_price - grant_price, 0) else: return n_options * np.maximum(current_price[-1] - grant_price, 0) def payout_otm_options(prices: np.array, grant_price: float, amount: float, immediate_exercise=False) -&gt; float: n_options = (amount / grant_price) 8 if immediate_exercise: # this possibility is not considered in the blog post, but is included for illustration return n_options np.maximum(current_price - 1.5 grant_price, 0) else: return n_options np.maximum(current_price[-1] - 1.5 * grant_price, 0) And, finally, here is the code to run the simulation loop (over all the different actor rulesets and parameter possibilities): from typing import Dict import numpy as np import pandas as pd ALLOCATION_RULESETS = { &quot;cash_only&quot;: { &quot;cash&quot;: 1, }, # (many rulesets omitted) &quot;even&quot;: { &quot;cash&quot;: 0.25, &quot;rsus&quot;: 0.25, &quot;atm_options&quot;: 0.25, &quot;otm_options&quot;: 0.25 }, } def get_allocation(allocation_ruleset: str, amount: float) -&gt; Dict[str, float]: frac_allocation = ALLOCATION_RULESETS[allocation_ruleset] return { equity_type: frac * amount for equity_type, frac in frac_allocation.items() } results = [] n_steps = 48 # 4 years * 12 months N_simulations = 1000 # chosen arbitrarily for allocation_ruleset in ALLOCATION_RULESETS.keys(): print(strategy) # divide total equity amount by number of time steps allocation = get_allocation(allocation_ruleset, amount=1/n_steps) for mu in np.linspace(-0.1/12, 0.2/12, 21): for sigma in np.linspace(0, 0.5/12, 21): for simulation_num in range(N_simulations): payouts = SimulationRunnerVectorized( mu=mu, sigma=sigma, n_steps=n_steps, allocation=allocation ).run() results.append({ &quot;mu&quot;: mu, &quot;sigma&quot;: sigma, &quot;simulation_num&quot;: i, &quot;strategy&quot;: strategy, &quot;payout&quot;: payouts.sum() }) results = pd.DataFrame(results) Note: there is some tricky logic here related to time. The time increments are monthly, which means that $\mu$ and $\sigma$ should also be treated as monthly rates of return and monthly drifts, respectively. With the parameter ranges chosen above, we cover a range of annual rates of return from roughly -10% to 20%. The values for $\sigma$ are also arbitrary, but the minimum value is 0 (in which case the simulation is deterministic), and the maximum value is on the order of $\mu$, which should make sense intuitively. Simulation results Leaving aside the subtle matter of converting between payouts and &quot;utility&quot;, we can present the simulation results for a given allocation ruleset as a contour plot, with the two main parameters ($\mu$ and $\sigma$) on x- and y-axes and the payout as the third dimension (the color/contour level). As an example, the &quot;cash only&quot; ruleset leads to a flat plot with 0.9 for all values of the parameters, since the cash payout does not depend on the stock price. (Note: we are also ignoring effects of inflation here.). More interesting are plots for some of the other allocation rulesets (note: I have multiplied by $\mu$ and $\sigma$ by 12, which roughly converts them to annual quantities) Allocation to RSUs only Allocation to ATM options only Allocation to OTM options only We can draw a few conclusions: For the rates of return being simulated, the OTM options are strictly inferior to the ATM options. They become superior only for higher annual rates of return (&gt;15%). This makes sense, given that the total appreciation over 4 years has to be &gt;50% for these options to be worth anything, let alone better than the other equity types. (Using a longer time horizon, such as ten years, which is the typical expiration date for options, would change these conclusions.) RSUs are relatively unaffected by volatility ($\sigma$), but increased volatility actually helps options moderately. This is not too surprising, since options are a one-sided bet: you make money if the stock price goes up a lot, but don&#39;t lose money if it goes down a lot. So, for a low rate of return, increased volatility increases the likelihood of both the former outcome and the latter outcome, resulting in a higher expected payout. Since the payouts are far more sensitive to $\mu$ than to $\sigma$, we can also plot these results in a more comprehensible line plot format, where we fix $\sigma$ (here, at $0.2/12$) and plot the results against $\mu$: This plot provides a useful graphical summary of the different growth assumptions under which the various equity types make sense. It also shows how mixing options with RSUs and/or cash (the &quot;default&quot; and &quot;even&quot; allocations) can provide a compromise that still provides some payout under negative or low stock price growth, while providing substantial upside under high stock price growth. Prior probabilities and utility functions Arguably, the most difficult part of this exercise is not implementing the simulation, but generating a sensible prior distribution. Most tech stocks are very young, and therefore there may not be sufficient historical data to inform a prior. Moreover, assuming that future stock price movements will follow historical trends is always a dangerous assumption. I don&#39;t have any great advice to provide here, but I think a wide Gaussian, centered at some positive rate of return that roughly equals the historical market return (say, S&amp;P 500 or Nasdaq), seems reasonable. This choice avoids being overly optimistic, comprises a wide range of scenarios (negative, low, and high growth) and does not rely too heavily on thin historical data. (Note: I am also only considering $\mu$ here. Estimating $\sigma$ is even more challenging, although, fortunately, it does not affect the results too much.) The utility function is also highly subjective. In my case, I am fairly risk-averse, and therefore my utility function is shaped concave downwards (see here for examples). In contrast, others may view equity as &quot;house money&quot;, and only care if they strike it rich and not care otherwise. This would be &quot;risk-seeking&quot; behavior. Ultimately, this is a personal decision that depends on your own financial situation and feelings towards money, and there is no single &quot;right&quot; answer. It is also not obvious whether we should be looking at the expected value at all, particularly if we are risk averse. Perhaps we&#39;d like to adopt a &quot;maximin&quot; approach, where we maximize the utility associated with a low-quantile outcome, such as the 10th or 25th percentile. This should be straightforward using the machinery we developed above, since we have effectively generated the entire payout probability distribution. The likely outcome, with respect to decision making, is that the optimal allocation shifts more towards cash/RSUs (safer assets) and away from options (riskier assets) Summary and conclusions To conclude: Monte Carlo simulations can be a powerful tool for decision making, when combined with a function that takes us from &quot;outcomes&quot; to &quot;utility&quot;. These simulations have several interrelated pieces: a parametric equation describing how to move from time $t$ to $t+1$; a prior probability distribution for these parameters; and a ruleset followed by the actor (if relevant). By running simulations from the same initial conditions $N$ times, where $N$ is sufficiently large, we can generate the complete probability distribution for the simulation outcomes. We applied this framework to a specific problem: how to allocate equity across 4 different asset types to maximize the expected utility associated with the payout. Using a geometric Brownian motion model for the stock price, and some (slick?) Python code, we generated vaguely pretty plots that showed how payouts change with the volatility ($\sigma$) and the rate of return ($\mu$). Unsurprisingly, the four different asset types behave very differently in negative, low, and high growth regimes, and their behavior can be smoothed out by blending different asset types together. The most difficult part of this exercise lies in the subjective/unknowable aspects: the prior probability distributions and the utility functions. There were many dubious assumptions made (neglecting taxation, assuming a geometric Brownian motion model for stock prices, settling on a simple-to-code but suboptimal strategy for exercising options, etc.), so this should not be taken as a final word on this problem. Indeed, the purpose was more to show an example of the Monte Carlo simulation technique than to decide on an &quot;optimal&quot; allocation ruleset for me. (For those who are curious, I plan to put the vast majority of my equity into RSUs; given my risk aversion, this decision makes more sense than the default allocation (75% RSUs, 25% ATM options), and RSUs are superior to cash even under somewhat pessimistic growth assumptions. That being said, I took the analysis above as more of a guide than anything else; I did not try to &quot;argmax&quot; my way to a decision.)" />
<meta property="og:description" content="Introduction I was lucky enough to receive an offer from a tech company recently, and, as part of that offer, a substantial equity package. This company allows you to choose your own mix of equity. The equity package can be allocated across four asset types: cash, restricted stock units (RSUs), and two types of options, one aggressive (&quot;at the money&quot;, or ATM) and the other very aggressive (&quot;out of the money&quot;, OTM). The value of the equity package, for the non-cash asset types, depends on how the stock price evolves during one&#39;s tenure. If the stock price increases greatly, the OTM and ATM options are superior to RSUs, which in turn is superior to cash. If the stock price drops, the ranking is reversed. While the HR department provided a helpful guide to understand the mechanics of each asset type, and informed me that, if I couldn&#39;t make a decision, I would be opted-in to a mix of 75% RSUs and 25% ATM options, I wanted to understand the value of this package in greater detail. (The term &quot;value&quot; is ill-defined, and I&#39;ll return to it later.) I decided to tackle this problem using simulation. The system being modeled can be divided into a few pieces: the actor (me), the equity package, and the stock price. Some of these, like the stock price, evolve endogenously, according to their own mechanics. (Presumably, I am a small enough actor that, while the stock price affects my decisions, like whether/when to exercise, my decisions do not affect the stock price.) Typically, these mechanics will be parametrized by random variables. For instance, as I&#39;ll discuss below, we can assume the stock price changes according to a &quot;geometric Brownian motion&quot; process in which there is a long-term, deterministic trend (parametrized by $\mu$) and short-term, stochastic volatility (parametrized by $\sigma$). I do not know the true values of $\mu$ or $\sigma$, and, if I did, I would be a retired multimillionaire instead of a humble blogpost writer. Instead, I have a rough idea of what reasonable values these parameters might take, based both on historical data as well as my knowledge of trends in the broader market. Running the simulation involves stepping from time $t$ to time $t+1$, and repeating this process $N$ times. What happens during each step? The stock price changes according to the mathematical model. Some of my equity vests. If that equity represents RSUs, I have a decision of whether or not to sell it immediately, or to hold it. And, if that equity represents options, I can choose to exercise and sell immediately, exercise and hold, or not exercise at all. The range of possibilities is actually quite daunting, and expands geometrically with each time increment. In what follows, I will make some (grossly) simplifying assumptions, but, in general, if we want to determine the actor&#39;s optimal decision over a range of simulations/scenarios, we need to optimize over the entire space of his/her decisions. In this example, that means optimizing both for the initial allocation decision --- what fraction of cash, RSUs, and options to choose --- and for the decision about exercising and selling at each time step. How does the &quot;optimization&quot; actually happen? This is actually quite complicated! One plausible approach, although by no means the only one, is to take the results of each simulation and assign a &quot;utility&quot; to each. I would have a function, $U(M_i)$, that describes my utility, $U$, corresponding to the money, $M_i$, generated from simulation $i$. This curve should be monotonically increasing, but need not be linear. Presumably my utility from making \$100k is not 10 times as much as making \$10k; there are diminishing returns to money. Then, the decision would be made on the basis of the actor&#39;s actions that maximize this expected utility. (This field of study is known as &quot;Decision Theory&quot;, if you&#39;d like to read more.) To try to summarize, the following is a generic approach to &quot;Monte Carlo&quot; simulation-based decision making. Model the system mathematically, which means formulating an equation that describes the evolution of the system from time $t$ to $t+1$. The model will possess parameters that govern the system dynamics. Try to formulate a (multivariate) prior distribution for these parameters. Create a set of possibilities for rulesets that the actor in the simulation will follow. Arbitrarily assign the actor a single ruleset based on the possibilities enumerated above. Randomly draw a sample from the prior distribution. Run the simulation with these sampled parameters and the chosen actor ruleset. The simulation will involve repeatedly stepping through time. Store the results and use our function $U$ to compute the associated utility of the &quot;possible future&quot; that we have simulated. Repeat steps 5-6 sufficient times that we have confidence in our estimate of the expected value of utility for the actor ruleset being considered. This is known as the &quot;Monte Carlo&quot; approach. Note that this step can be very expensive, depending on how long it takes for each simulation to run, and how many simulations are required to reach &quot;convergence&quot;. Repeat steps 5-7 for all possible actor rulesets. Maximize the expected utility with respect to the ruleset. Presumably, this is the ruleset we want to follow in practice. Of course, this recommendation is only as good as the assumptions that underpin it: the simplifications made in the mathematical model, the correctness of the prior distribution, the comprehensiveness of the possibilities for rulesets, etc. All of this is somewhat abstract, so let&#39;s use my actual example to make these concepts more concrete. Case study Mathematical model As mentioned above, there are three pieces here: the actor (me), the equity package, and the stock price. The dynamics of the equity package are fairly simple. Excluding some minor details like the &quot;equity cliff&quot;, at each timestep, a fraction 1/N of the equity vests. For instance, if the equity package is \$24k, and, assuming a 4 year vesting schedule, each month \$500 will vest. How this vesting translates into real money (and, in turn how that real money translates into &quot;utility&quot;) is more complicated, and will be discussed later. The stock price is assumed to follow a &quot;Geometric Brownian Motion&quot; model. This essentially decomposes the rate of return into two parts, one deterministic ($\mu$) and one stochastic ($\sigma$). The former describes how the stock price would evolve in the absence of volatility (the &quot;drift&quot;), and the latter accounts for the volatility. Because one of these terms describes a stochastic process, different simulations with the same set of parameters ($\mu$, $\sigma$) will give different results. The governing equation is: $$ S_t / S_{t-1} = \exp(\mu - \sigma^2/2 + \sigma N(0, 1)) $$ where $S_{t}$ is the stock price at time $t$, and $N(0, 1)$ is a unit normal distribution. (Important note: I do not work in finance, and I am certainly not an expert in financial modeling. I chose this model because it seemed widely used and reasonably tractable, but the assumptions of constant variance and Gaussian processes are known to be dubious, and I&#39;m including this caveat so that Nassim Taleb doesn&#39;t yell at me.) Actor&#39;s rulesets There are two main decisons the actor makes. At $t = 0$, the actor decides how to allocate his/her equity across the four asset types: cash, RSUs, ATM options, and OTM options. Then, at each $t &gt; 0$, the actor decides what to do with the equity that has vested. Let&#39;s cover each in turn. Cash is very simple. Equity of amount $M_t$ vests at $t$, and the actor receives a &quot;payout&quot; of $0.9M_t$ in their bank account. (Note: The 0.9 factor is apparently related to tax reasons for the company. I am also ignoring taxation for the individual, which is a very big oversight, and, as a consequence, the numerical results below should not be taken as accurate. That being said, given the actor rulesets under consideration, the taxation of cash and RSUs is similar, so this effect is mostly irrelevant if options are not part of the allocation.) RSUs are also fairly simple. At each time $t$, the actor receives a number of shares equal to $M_t / S_0$: i.e, the nominal value of the equity is divided by the stock price at the grant date, not at the vesting date. So, the actual value of these shares is $M_t * S_{t} / S_{0}$: the shares are worth more than cash (ignoring the discounting factor of 0.9) if the stock appreciates, and the shares are worth less if the opposite is true. I will assume that the actor is conservative, and will sell the RSUs immediately after vesting. (This is not as stupid as it sounds: because RSUs are taxed on vesting, there is no real tax benefit to delaying the sale, and one can hedge against the company&#39;s stock by investing the proceeds into an index fund. In other words, we can imagine two scenarios: one in which we sell the shares and reinvest the same amount in the company (which is equivalent to holding); the other where we sell the shares and reinvest them in a diversified financial product. If the actor was given separate money for this, he/she would invariably choose the second option. So why should it be different if the actor is given money in the form of RSUs?) Options are somewhat more complicated. Here I will make the somewhat questionable assumption that options are exercised at the end of the time period under consideration, with the caveat that they are not exercised if they are worthless. For ATM options, options are worth something if $S_{t} &gt; S_{0}$: the stock has to appreciate. For OTM options, options are worth something only if $S_{t} &gt; 1.5S_{0}$: the stock has to appreciate by at least 50%. To justify this extra risk relative to RSUs, 4 times as many ATM options are given as RSUs for a given equity amount, and the corresponding ratio is 8 for OTM options. The payouts end up being $4 (M / S_0) \max(S_{t_{end}} - S_0, 0)$ for ATM, and $8 (M / S_0) \max(S_{t_{end}} - 1.5 S_0, 0)$ for OTM, where $M$ is the total amount of equity (so, $NM_t$, where $N$ is the number of time steps). Other rulesets are possible for options. The disadvantage of the one under consideration is that the tax bill will be enormous if the options are worth a significant amount, since the gains are concentrated in a single year instead of being more spread out. We can also imagine immediate exercise (which probably doesn&#39;t make sense, especially for OTM options), and exercise as soon as the options are worth a certain amount. These are more complicated to model, however. For the initial allocation decision, I will assume a few different possibilities, summarized in the table below: Python code The python code to run the simulation and model the payouts is presented below. The version I present is vectorized, which makes the computation faster but also perhaps less readable. Note that, in general, it&#39;s easier to program these simulations step-by-step (advancing from $t$ to $t+1$), but this may less computationally efficient. import numpy as np class SimulationRunnerVectorized: def init(self, mu, sigma, n_steps, allocation, price=1): &quot;&quot;&quot; Initialize using parameters (mu, sigma), actor rulesets (allocation), and number of timesteps. The initial stock price can be set to 1 without loss of generality &quot;&quot;&quot; self.mu = mu self.sigma = sigma self.n_steps = n_steps self.grant_price = price self.price = price self.allocation = { equity_type: np.ones(n_steps, ) * amount for equity_type, amount in allocation.items() } &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compute_prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Compute stock prices for all timesteps&quot;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rate_of_return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sigma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cumprod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rate_of_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Run simulation: compute stock prices given initial allocation; compute final payouts&quot;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute_prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payouts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate_payout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grant_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grant_price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payouts&lt;/span&gt; Here is the code for calculating the payouts from the simulation results from typing import Callable, Dict import numpy as np def calculate_payout(prices: np.array, grant_price: float, allocation: Dict[str, Callable]) -&gt; float: &quot;&quot;&quot;Calculate payout by aggregating over all equity types&quot;&quot;&quot; payout = 0 payout_funcs = { &quot;cash&quot;: payout_cash, &quot;rsus&quot;: payout_rsus, &quot;atm_options&quot;: payout_atm_options, &quot;otm_options&quot;: payout_otm_options, } for equity_type, amount in allocation.items(): payout += payout_funcs[equity_type](prices, grant_price, amount=amount) return payout def payout_cash(prices: np.array, grant_price: float, amount: float, discount: float=0.1) -&gt; float: return amount * (1 - discount) def payout_rsus(prices: np.array, grant_price: float, amount: float): n_shares = (amount / grant_price) return n_shares * prices def payout_atm_options(prices: np.array, grant_price: float, amount: float, immediate_exercise: bool=False) -&gt; float: n_options = (amount / grant_price) 4 if immediate_exercise: # this possibility is not considered in the blog post, but is included for illustration return n_options np.maximum(current_price - grant_price, 0) else: return n_options * np.maximum(current_price[-1] - grant_price, 0) def payout_otm_options(prices: np.array, grant_price: float, amount: float, immediate_exercise=False) -&gt; float: n_options = (amount / grant_price) 8 if immediate_exercise: # this possibility is not considered in the blog post, but is included for illustration return n_options np.maximum(current_price - 1.5 grant_price, 0) else: return n_options np.maximum(current_price[-1] - 1.5 * grant_price, 0) And, finally, here is the code to run the simulation loop (over all the different actor rulesets and parameter possibilities): from typing import Dict import numpy as np import pandas as pd ALLOCATION_RULESETS = { &quot;cash_only&quot;: { &quot;cash&quot;: 1, }, # (many rulesets omitted) &quot;even&quot;: { &quot;cash&quot;: 0.25, &quot;rsus&quot;: 0.25, &quot;atm_options&quot;: 0.25, &quot;otm_options&quot;: 0.25 }, } def get_allocation(allocation_ruleset: str, amount: float) -&gt; Dict[str, float]: frac_allocation = ALLOCATION_RULESETS[allocation_ruleset] return { equity_type: frac * amount for equity_type, frac in frac_allocation.items() } results = [] n_steps = 48 # 4 years * 12 months N_simulations = 1000 # chosen arbitrarily for allocation_ruleset in ALLOCATION_RULESETS.keys(): print(strategy) # divide total equity amount by number of time steps allocation = get_allocation(allocation_ruleset, amount=1/n_steps) for mu in np.linspace(-0.1/12, 0.2/12, 21): for sigma in np.linspace(0, 0.5/12, 21): for simulation_num in range(N_simulations): payouts = SimulationRunnerVectorized( mu=mu, sigma=sigma, n_steps=n_steps, allocation=allocation ).run() results.append({ &quot;mu&quot;: mu, &quot;sigma&quot;: sigma, &quot;simulation_num&quot;: i, &quot;strategy&quot;: strategy, &quot;payout&quot;: payouts.sum() }) results = pd.DataFrame(results) Note: there is some tricky logic here related to time. The time increments are monthly, which means that $\mu$ and $\sigma$ should also be treated as monthly rates of return and monthly drifts, respectively. With the parameter ranges chosen above, we cover a range of annual rates of return from roughly -10% to 20%. The values for $\sigma$ are also arbitrary, but the minimum value is 0 (in which case the simulation is deterministic), and the maximum value is on the order of $\mu$, which should make sense intuitively. Simulation results Leaving aside the subtle matter of converting between payouts and &quot;utility&quot;, we can present the simulation results for a given allocation ruleset as a contour plot, with the two main parameters ($\mu$ and $\sigma$) on x- and y-axes and the payout as the third dimension (the color/contour level). As an example, the &quot;cash only&quot; ruleset leads to a flat plot with 0.9 for all values of the parameters, since the cash payout does not depend on the stock price. (Note: we are also ignoring effects of inflation here.). More interesting are plots for some of the other allocation rulesets (note: I have multiplied by $\mu$ and $\sigma$ by 12, which roughly converts them to annual quantities) Allocation to RSUs only Allocation to ATM options only Allocation to OTM options only We can draw a few conclusions: For the rates of return being simulated, the OTM options are strictly inferior to the ATM options. They become superior only for higher annual rates of return (&gt;15%). This makes sense, given that the total appreciation over 4 years has to be &gt;50% for these options to be worth anything, let alone better than the other equity types. (Using a longer time horizon, such as ten years, which is the typical expiration date for options, would change these conclusions.) RSUs are relatively unaffected by volatility ($\sigma$), but increased volatility actually helps options moderately. This is not too surprising, since options are a one-sided bet: you make money if the stock price goes up a lot, but don&#39;t lose money if it goes down a lot. So, for a low rate of return, increased volatility increases the likelihood of both the former outcome and the latter outcome, resulting in a higher expected payout. Since the payouts are far more sensitive to $\mu$ than to $\sigma$, we can also plot these results in a more comprehensible line plot format, where we fix $\sigma$ (here, at $0.2/12$) and plot the results against $\mu$: This plot provides a useful graphical summary of the different growth assumptions under which the various equity types make sense. It also shows how mixing options with RSUs and/or cash (the &quot;default&quot; and &quot;even&quot; allocations) can provide a compromise that still provides some payout under negative or low stock price growth, while providing substantial upside under high stock price growth. Prior probabilities and utility functions Arguably, the most difficult part of this exercise is not implementing the simulation, but generating a sensible prior distribution. Most tech stocks are very young, and therefore there may not be sufficient historical data to inform a prior. Moreover, assuming that future stock price movements will follow historical trends is always a dangerous assumption. I don&#39;t have any great advice to provide here, but I think a wide Gaussian, centered at some positive rate of return that roughly equals the historical market return (say, S&amp;P 500 or Nasdaq), seems reasonable. This choice avoids being overly optimistic, comprises a wide range of scenarios (negative, low, and high growth) and does not rely too heavily on thin historical data. (Note: I am also only considering $\mu$ here. Estimating $\sigma$ is even more challenging, although, fortunately, it does not affect the results too much.) The utility function is also highly subjective. In my case, I am fairly risk-averse, and therefore my utility function is shaped concave downwards (see here for examples). In contrast, others may view equity as &quot;house money&quot;, and only care if they strike it rich and not care otherwise. This would be &quot;risk-seeking&quot; behavior. Ultimately, this is a personal decision that depends on your own financial situation and feelings towards money, and there is no single &quot;right&quot; answer. It is also not obvious whether we should be looking at the expected value at all, particularly if we are risk averse. Perhaps we&#39;d like to adopt a &quot;maximin&quot; approach, where we maximize the utility associated with a low-quantile outcome, such as the 10th or 25th percentile. This should be straightforward using the machinery we developed above, since we have effectively generated the entire payout probability distribution. The likely outcome, with respect to decision making, is that the optimal allocation shifts more towards cash/RSUs (safer assets) and away from options (riskier assets) Summary and conclusions To conclude: Monte Carlo simulations can be a powerful tool for decision making, when combined with a function that takes us from &quot;outcomes&quot; to &quot;utility&quot;. These simulations have several interrelated pieces: a parametric equation describing how to move from time $t$ to $t+1$; a prior probability distribution for these parameters; and a ruleset followed by the actor (if relevant). By running simulations from the same initial conditions $N$ times, where $N$ is sufficiently large, we can generate the complete probability distribution for the simulation outcomes. We applied this framework to a specific problem: how to allocate equity across 4 different asset types to maximize the expected utility associated with the payout. Using a geometric Brownian motion model for the stock price, and some (slick?) Python code, we generated vaguely pretty plots that showed how payouts change with the volatility ($\sigma$) and the rate of return ($\mu$). Unsurprisingly, the four different asset types behave very differently in negative, low, and high growth regimes, and their behavior can be smoothed out by blending different asset types together. The most difficult part of this exercise lies in the subjective/unknowable aspects: the prior probability distributions and the utility functions. There were many dubious assumptions made (neglecting taxation, assuming a geometric Brownian motion model for stock prices, settling on a simple-to-code but suboptimal strategy for exercising options, etc.), so this should not be taken as a final word on this problem. Indeed, the purpose was more to show an example of the Monte Carlo simulation technique than to decide on an &quot;optimal&quot; allocation ruleset for me. (For those who are curious, I plan to put the vast majority of my equity into RSUs; given my risk aversion, this decision makes more sense than the default allocation (75% RSUs, 25% ATM options), and RSUs are superior to cash even under somewhat pessimistic growth assumptions. That being said, I took the analysis above as more of a guide than anything else; I did not try to &quot;argmax&quot; my way to a decision.)" />
<link rel="canonical" href="http://localhost:4000/blog/a-random-walk-down-wall-street/" />
<meta property="og:url" content="http://localhost:4000/blog/a-random-walk-down-wall-street/" />
<meta property="og:site_name" content="Varun&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-26T20:07:59-08:00" />
<script type="application/ld+json">
{"description":"Introduction I was lucky enough to receive an offer from a tech company recently, and, as part of that offer, a substantial equity package. This company allows you to choose your own mix of equity. The equity package can be allocated across four asset types: cash, restricted stock units (RSUs), and two types of options, one aggressive (&quot;at the money&quot;, or ATM) and the other very aggressive (&quot;out of the money&quot;, OTM). The value of the equity package, for the non-cash asset types, depends on how the stock price evolves during one&#39;s tenure. If the stock price increases greatly, the OTM and ATM options are superior to RSUs, which in turn is superior to cash. If the stock price drops, the ranking is reversed. While the HR department provided a helpful guide to understand the mechanics of each asset type, and informed me that, if I couldn&#39;t make a decision, I would be opted-in to a mix of 75% RSUs and 25% ATM options, I wanted to understand the value of this package in greater detail. (The term &quot;value&quot; is ill-defined, and I&#39;ll return to it later.) I decided to tackle this problem using simulation. The system being modeled can be divided into a few pieces: the actor (me), the equity package, and the stock price. Some of these, like the stock price, evolve endogenously, according to their own mechanics. (Presumably, I am a small enough actor that, while the stock price affects my decisions, like whether/when to exercise, my decisions do not affect the stock price.) Typically, these mechanics will be parametrized by random variables. For instance, as I&#39;ll discuss below, we can assume the stock price changes according to a &quot;geometric Brownian motion&quot; process in which there is a long-term, deterministic trend (parametrized by $\\mu$) and short-term, stochastic volatility (parametrized by $\\sigma$). I do not know the true values of $\\mu$ or $\\sigma$, and, if I did, I would be a retired multimillionaire instead of a humble blogpost writer. Instead, I have a rough idea of what reasonable values these parameters might take, based both on historical data as well as my knowledge of trends in the broader market. Running the simulation involves stepping from time $t$ to time $t+1$, and repeating this process $N$ times. What happens during each step? The stock price changes according to the mathematical model. Some of my equity vests. If that equity represents RSUs, I have a decision of whether or not to sell it immediately, or to hold it. And, if that equity represents options, I can choose to exercise and sell immediately, exercise and hold, or not exercise at all. The range of possibilities is actually quite daunting, and expands geometrically with each time increment. In what follows, I will make some (grossly) simplifying assumptions, but, in general, if we want to determine the actor&#39;s optimal decision over a range of simulations/scenarios, we need to optimize over the entire space of his/her decisions. In this example, that means optimizing both for the initial allocation decision --- what fraction of cash, RSUs, and options to choose --- and for the decision about exercising and selling at each time step. How does the &quot;optimization&quot; actually happen? This is actually quite complicated! One plausible approach, although by no means the only one, is to take the results of each simulation and assign a &quot;utility&quot; to each. I would have a function, $U(M_i)$, that describes my utility, $U$, corresponding to the money, $M_i$, generated from simulation $i$. This curve should be monotonically increasing, but need not be linear. Presumably my utility from making \\$100k is not 10 times as much as making \\$10k; there are diminishing returns to money. Then, the decision would be made on the basis of the actor&#39;s actions that maximize this expected utility. (This field of study is known as &quot;Decision Theory&quot;, if you&#39;d like to read more.) To try to summarize, the following is a generic approach to &quot;Monte Carlo&quot; simulation-based decision making. Model the system mathematically, which means formulating an equation that describes the evolution of the system from time $t$ to $t+1$. The model will possess parameters that govern the system dynamics. Try to formulate a (multivariate) prior distribution for these parameters. Create a set of possibilities for rulesets that the actor in the simulation will follow. Arbitrarily assign the actor a single ruleset based on the possibilities enumerated above. Randomly draw a sample from the prior distribution. Run the simulation with these sampled parameters and the chosen actor ruleset. The simulation will involve repeatedly stepping through time. Store the results and use our function $U$ to compute the associated utility of the &quot;possible future&quot; that we have simulated. Repeat steps 5-6 sufficient times that we have confidence in our estimate of the expected value of utility for the actor ruleset being considered. This is known as the &quot;Monte Carlo&quot; approach. Note that this step can be very expensive, depending on how long it takes for each simulation to run, and how many simulations are required to reach &quot;convergence&quot;. Repeat steps 5-7 for all possible actor rulesets. Maximize the expected utility with respect to the ruleset. Presumably, this is the ruleset we want to follow in practice. Of course, this recommendation is only as good as the assumptions that underpin it: the simplifications made in the mathematical model, the correctness of the prior distribution, the comprehensiveness of the possibilities for rulesets, etc. All of this is somewhat abstract, so let&#39;s use my actual example to make these concepts more concrete. Case study Mathematical model As mentioned above, there are three pieces here: the actor (me), the equity package, and the stock price. The dynamics of the equity package are fairly simple. Excluding some minor details like the &quot;equity cliff&quot;, at each timestep, a fraction 1/N of the equity vests. For instance, if the equity package is \\$24k, and, assuming a 4 year vesting schedule, each month \\$500 will vest. How this vesting translates into real money (and, in turn how that real money translates into &quot;utility&quot;) is more complicated, and will be discussed later. The stock price is assumed to follow a &quot;Geometric Brownian Motion&quot; model. This essentially decomposes the rate of return into two parts, one deterministic ($\\mu$) and one stochastic ($\\sigma$). The former describes how the stock price would evolve in the absence of volatility (the &quot;drift&quot;), and the latter accounts for the volatility. Because one of these terms describes a stochastic process, different simulations with the same set of parameters ($\\mu$, $\\sigma$) will give different results. The governing equation is: $$ S_t / S_{t-1} = \\exp(\\mu - \\sigma^2/2 + \\sigma N(0, 1)) $$ where $S_{t}$ is the stock price at time $t$, and $N(0, 1)$ is a unit normal distribution. (Important note: I do not work in finance, and I am certainly not an expert in financial modeling. I chose this model because it seemed widely used and reasonably tractable, but the assumptions of constant variance and Gaussian processes are known to be dubious, and I&#39;m including this caveat so that Nassim Taleb doesn&#39;t yell at me.) Actor&#39;s rulesets There are two main decisons the actor makes. At $t = 0$, the actor decides how to allocate his/her equity across the four asset types: cash, RSUs, ATM options, and OTM options. Then, at each $t &gt; 0$, the actor decides what to do with the equity that has vested. Let&#39;s cover each in turn. Cash is very simple. Equity of amount $M_t$ vests at $t$, and the actor receives a &quot;payout&quot; of $0.9M_t$ in their bank account. (Note: The 0.9 factor is apparently related to tax reasons for the company. I am also ignoring taxation for the individual, which is a very big oversight, and, as a consequence, the numerical results below should not be taken as accurate. That being said, given the actor rulesets under consideration, the taxation of cash and RSUs is similar, so this effect is mostly irrelevant if options are not part of the allocation.) RSUs are also fairly simple. At each time $t$, the actor receives a number of shares equal to $M_t / S_0$: i.e, the nominal value of the equity is divided by the stock price at the grant date, not at the vesting date. So, the actual value of these shares is $M_t * S_{t} / S_{0}$: the shares are worth more than cash (ignoring the discounting factor of 0.9) if the stock appreciates, and the shares are worth less if the opposite is true. I will assume that the actor is conservative, and will sell the RSUs immediately after vesting. (This is not as stupid as it sounds: because RSUs are taxed on vesting, there is no real tax benefit to delaying the sale, and one can hedge against the company&#39;s stock by investing the proceeds into an index fund. In other words, we can imagine two scenarios: one in which we sell the shares and reinvest the same amount in the company (which is equivalent to holding); the other where we sell the shares and reinvest them in a diversified financial product. If the actor was given separate money for this, he/she would invariably choose the second option. So why should it be different if the actor is given money in the form of RSUs?) Options are somewhat more complicated. Here I will make the somewhat questionable assumption that options are exercised at the end of the time period under consideration, with the caveat that they are not exercised if they are worthless. For ATM options, options are worth something if $S_{t} &gt; S_{0}$: the stock has to appreciate. For OTM options, options are worth something only if $S_{t} &gt; 1.5S_{0}$: the stock has to appreciate by at least 50%. To justify this extra risk relative to RSUs, 4 times as many ATM options are given as RSUs for a given equity amount, and the corresponding ratio is 8 for OTM options. The payouts end up being $4 (M / S_0) \\max(S_{t_{end}} - S_0, 0)$ for ATM, and $8 (M / S_0) \\max(S_{t_{end}} - 1.5 S_0, 0)$ for OTM, where $M$ is the total amount of equity (so, $NM_t$, where $N$ is the number of time steps). Other rulesets are possible for options. The disadvantage of the one under consideration is that the tax bill will be enormous if the options are worth a significant amount, since the gains are concentrated in a single year instead of being more spread out. We can also imagine immediate exercise (which probably doesn&#39;t make sense, especially for OTM options), and exercise as soon as the options are worth a certain amount. These are more complicated to model, however. For the initial allocation decision, I will assume a few different possibilities, summarized in the table below: Python code The python code to run the simulation and model the payouts is presented below. The version I present is vectorized, which makes the computation faster but also perhaps less readable. Note that, in general, it&#39;s easier to program these simulations step-by-step (advancing from $t$ to $t+1$), but this may less computationally efficient. import numpy as np class SimulationRunnerVectorized: def init(self, mu, sigma, n_steps, allocation, price=1): &quot;&quot;&quot; Initialize using parameters (mu, sigma), actor rulesets (allocation), and number of timesteps. The initial stock price can be set to 1 without loss of generality &quot;&quot;&quot; self.mu = mu self.sigma = sigma self.n_steps = n_steps self.grant_price = price self.price = price self.allocation = { equity_type: np.ones(n_steps, ) * amount for equity_type, amount in allocation.items() } &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compute_prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Compute stock prices for all timesteps&quot;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rate_of_return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sigma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cumprod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rate_of_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Run simulation: compute stock prices given initial allocation; compute final payouts&quot;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute_prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payouts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate_payout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grant_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grant_price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payouts&lt;/span&gt; Here is the code for calculating the payouts from the simulation results from typing import Callable, Dict import numpy as np def calculate_payout(prices: np.array, grant_price: float, allocation: Dict[str, Callable]) -&gt; float: &quot;&quot;&quot;Calculate payout by aggregating over all equity types&quot;&quot;&quot; payout = 0 payout_funcs = { &quot;cash&quot;: payout_cash, &quot;rsus&quot;: payout_rsus, &quot;atm_options&quot;: payout_atm_options, &quot;otm_options&quot;: payout_otm_options, } for equity_type, amount in allocation.items(): payout += payout_funcs[equity_type](prices, grant_price, amount=amount) return payout def payout_cash(prices: np.array, grant_price: float, amount: float, discount: float=0.1) -&gt; float: return amount * (1 - discount) def payout_rsus(prices: np.array, grant_price: float, amount: float): n_shares = (amount / grant_price) return n_shares * prices def payout_atm_options(prices: np.array, grant_price: float, amount: float, immediate_exercise: bool=False) -&gt; float: n_options = (amount / grant_price) 4 if immediate_exercise: # this possibility is not considered in the blog post, but is included for illustration return n_options np.maximum(current_price - grant_price, 0) else: return n_options * np.maximum(current_price[-1] - grant_price, 0) def payout_otm_options(prices: np.array, grant_price: float, amount: float, immediate_exercise=False) -&gt; float: n_options = (amount / grant_price) 8 if immediate_exercise: # this possibility is not considered in the blog post, but is included for illustration return n_options np.maximum(current_price - 1.5 grant_price, 0) else: return n_options np.maximum(current_price[-1] - 1.5 * grant_price, 0) And, finally, here is the code to run the simulation loop (over all the different actor rulesets and parameter possibilities): from typing import Dict import numpy as np import pandas as pd ALLOCATION_RULESETS = { &quot;cash_only&quot;: { &quot;cash&quot;: 1, }, # (many rulesets omitted) &quot;even&quot;: { &quot;cash&quot;: 0.25, &quot;rsus&quot;: 0.25, &quot;atm_options&quot;: 0.25, &quot;otm_options&quot;: 0.25 }, } def get_allocation(allocation_ruleset: str, amount: float) -&gt; Dict[str, float]: frac_allocation = ALLOCATION_RULESETS[allocation_ruleset] return { equity_type: frac * amount for equity_type, frac in frac_allocation.items() } results = [] n_steps = 48 # 4 years * 12 months N_simulations = 1000 # chosen arbitrarily for allocation_ruleset in ALLOCATION_RULESETS.keys(): print(strategy) # divide total equity amount by number of time steps allocation = get_allocation(allocation_ruleset, amount=1/n_steps) for mu in np.linspace(-0.1/12, 0.2/12, 21): for sigma in np.linspace(0, 0.5/12, 21): for simulation_num in range(N_simulations): payouts = SimulationRunnerVectorized( mu=mu, sigma=sigma, n_steps=n_steps, allocation=allocation ).run() results.append({ &quot;mu&quot;: mu, &quot;sigma&quot;: sigma, &quot;simulation_num&quot;: i, &quot;strategy&quot;: strategy, &quot;payout&quot;: payouts.sum() }) results = pd.DataFrame(results) Note: there is some tricky logic here related to time. The time increments are monthly, which means that $\\mu$ and $\\sigma$ should also be treated as monthly rates of return and monthly drifts, respectively. With the parameter ranges chosen above, we cover a range of annual rates of return from roughly -10% to 20%. The values for $\\sigma$ are also arbitrary, but the minimum value is 0 (in which case the simulation is deterministic), and the maximum value is on the order of $\\mu$, which should make sense intuitively. Simulation results Leaving aside the subtle matter of converting between payouts and &quot;utility&quot;, we can present the simulation results for a given allocation ruleset as a contour plot, with the two main parameters ($\\mu$ and $\\sigma$) on x- and y-axes and the payout as the third dimension (the color/contour level). As an example, the &quot;cash only&quot; ruleset leads to a flat plot with 0.9 for all values of the parameters, since the cash payout does not depend on the stock price. (Note: we are also ignoring effects of inflation here.). More interesting are plots for some of the other allocation rulesets (note: I have multiplied by $\\mu$ and $\\sigma$ by 12, which roughly converts them to annual quantities) Allocation to RSUs only Allocation to ATM options only Allocation to OTM options only We can draw a few conclusions: For the rates of return being simulated, the OTM options are strictly inferior to the ATM options. They become superior only for higher annual rates of return (&gt;15%). This makes sense, given that the total appreciation over 4 years has to be &gt;50% for these options to be worth anything, let alone better than the other equity types. (Using a longer time horizon, such as ten years, which is the typical expiration date for options, would change these conclusions.) RSUs are relatively unaffected by volatility ($\\sigma$), but increased volatility actually helps options moderately. This is not too surprising, since options are a one-sided bet: you make money if the stock price goes up a lot, but don&#39;t lose money if it goes down a lot. So, for a low rate of return, increased volatility increases the likelihood of both the former outcome and the latter outcome, resulting in a higher expected payout. Since the payouts are far more sensitive to $\\mu$ than to $\\sigma$, we can also plot these results in a more comprehensible line plot format, where we fix $\\sigma$ (here, at $0.2/12$) and plot the results against $\\mu$: This plot provides a useful graphical summary of the different growth assumptions under which the various equity types make sense. It also shows how mixing options with RSUs and/or cash (the &quot;default&quot; and &quot;even&quot; allocations) can provide a compromise that still provides some payout under negative or low stock price growth, while providing substantial upside under high stock price growth. Prior probabilities and utility functions Arguably, the most difficult part of this exercise is not implementing the simulation, but generating a sensible prior distribution. Most tech stocks are very young, and therefore there may not be sufficient historical data to inform a prior. Moreover, assuming that future stock price movements will follow historical trends is always a dangerous assumption. I don&#39;t have any great advice to provide here, but I think a wide Gaussian, centered at some positive rate of return that roughly equals the historical market return (say, S&amp;P 500 or Nasdaq), seems reasonable. This choice avoids being overly optimistic, comprises a wide range of scenarios (negative, low, and high growth) and does not rely too heavily on thin historical data. (Note: I am also only considering $\\mu$ here. Estimating $\\sigma$ is even more challenging, although, fortunately, it does not affect the results too much.) The utility function is also highly subjective. In my case, I am fairly risk-averse, and therefore my utility function is shaped concave downwards (see here for examples). In contrast, others may view equity as &quot;house money&quot;, and only care if they strike it rich and not care otherwise. This would be &quot;risk-seeking&quot; behavior. Ultimately, this is a personal decision that depends on your own financial situation and feelings towards money, and there is no single &quot;right&quot; answer. It is also not obvious whether we should be looking at the expected value at all, particularly if we are risk averse. Perhaps we&#39;d like to adopt a &quot;maximin&quot; approach, where we maximize the utility associated with a low-quantile outcome, such as the 10th or 25th percentile. This should be straightforward using the machinery we developed above, since we have effectively generated the entire payout probability distribution. The likely outcome, with respect to decision making, is that the optimal allocation shifts more towards cash/RSUs (safer assets) and away from options (riskier assets) Summary and conclusions To conclude: Monte Carlo simulations can be a powerful tool for decision making, when combined with a function that takes us from &quot;outcomes&quot; to &quot;utility&quot;. These simulations have several interrelated pieces: a parametric equation describing how to move from time $t$ to $t+1$; a prior probability distribution for these parameters; and a ruleset followed by the actor (if relevant). By running simulations from the same initial conditions $N$ times, where $N$ is sufficiently large, we can generate the complete probability distribution for the simulation outcomes. We applied this framework to a specific problem: how to allocate equity across 4 different asset types to maximize the expected utility associated with the payout. Using a geometric Brownian motion model for the stock price, and some (slick?) Python code, we generated vaguely pretty plots that showed how payouts change with the volatility ($\\sigma$) and the rate of return ($\\mu$). Unsurprisingly, the four different asset types behave very differently in negative, low, and high growth regimes, and their behavior can be smoothed out by blending different asset types together. The most difficult part of this exercise lies in the subjective/unknowable aspects: the prior probability distributions and the utility functions. There were many dubious assumptions made (neglecting taxation, assuming a geometric Brownian motion model for stock prices, settling on a simple-to-code but suboptimal strategy for exercising options, etc.), so this should not be taken as a final word on this problem. Indeed, the purpose was more to show an example of the Monte Carlo simulation technique than to decide on an &quot;optimal&quot; allocation ruleset for me. (For those who are curious, I plan to put the vast majority of my equity into RSUs; given my risk aversion, this decision makes more sense than the default allocation (75% RSUs, 25% ATM options), and RSUs are superior to cash even under somewhat pessimistic growth assumptions. That being said, I took the analysis above as more of a guide than anything else; I did not try to &quot;argmax&quot; my way to a decision.)","url":"http://localhost:4000/blog/a-random-walk-down-wall-street/","@type":"BlogPosting","headline":"A random walk down Wall Street","dateModified":"2021-11-26T20:07:59-08:00","datePublished":"2021-11-26T20:07:59-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/a-random-walk-down-wall-street/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Varun's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Varun&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">A random walk down Wall Street</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-11-26T20:07:59-08:00" itemprop="datePublished">Nov 26, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>I was lucky enough to receive an offer from a tech company recently, and, as part of that offer, a substantial equity package. This company allows you to choose your own mix of equity. The equity package can be allocated across four asset types: cash, restricted stock units (RSUs), and two types of options, one aggressive (&quot;at the money&quot;, or ATM) and the other very aggressive (&quot;out of the money&quot;, OTM). The value of the equity package, for the non-cash asset types, depends on how the stock price evolves during one's tenure. If the stock price increases greatly, the OTM and ATM options are superior to RSUs, which in turn is superior to cash. If the stock price drops, the ranking is reversed. While the HR department provided a helpful guide to understand the mechanics of each asset type, and informed me that, if I couldn't make a decision, I would be opted-in to a mix of 75% RSUs and 25% ATM options, I wanted to understand the value of this package in greater detail. (The term &quot;value&quot; is ill-defined, and I'll return to it later.)</p>
<p>I decided to tackle this problem using simulation. The system being modeled can be divided into a few pieces: the actor (me), the equity package, and the stock price. Some of these, like the stock price, evolve endogenously, according to their own mechanics. (Presumably, I am a small enough actor that, while the stock price affects my decisions, like whether/when to exercise, my decisions do not affect the stock price.) Typically, these mechanics will be parametrized by random variables. For instance, as I'll discuss below, we can assume the stock price changes according to a &quot;geometric Brownian motion&quot; process in which there is a long-term, deterministic trend (parametrized by $\mu$) and short-term, stochastic volatility (parametrized by $\sigma$). I do not know the true values of $\mu$ or $\sigma$, and, if I did, I would be a retired multimillionaire instead of a humble blogpost writer. Instead, I have a rough idea of what reasonable values these parameters might take, based both on historical data as well as my knowledge of trends in the broader market.</p>
<p>Running the simulation involves stepping from time $t$ to time $t+1$, and repeating this process $N$ times. What happens during each step? The stock price changes according to the mathematical model. Some of my equity vests. If that equity represents RSUs, I have a decision of whether or not to sell it immediately, or to hold it. And, if that equity represents options, I can choose to exercise and sell immediately, exercise and hold, or not exercise at all. The range of possibilities is actually quite daunting, and expands geometrically with each time increment. In what follows, I will make some (grossly) simplifying assumptions, but, in general, if we want to determine the actor's optimal decision over a range of simulations/scenarios, we need to optimize over the <em>entire</em> space of his/her decisions. In this example, that means optimizing both for the initial allocation decision --- what fraction of cash, RSUs, and options to choose --- and for the decision about exercising and selling at each time step.</p>
<p>How does the &quot;optimization&quot; actually happen? This is actually quite complicated! One plausible approach, although by no means the only one, is to take the results of each simulation and assign a &quot;utility&quot; to each. I would have a function, $U(M_i)$, that describes my utility, $U$, corresponding to the money, $M_i$, generated from simulation $i$. This curve should be monotonically increasing, but need not be linear. Presumably my utility from making \$100k is not 10 times as much as making \$10k; there are diminishing returns to money. Then, the decision would be made on the basis of the actor's actions that maximize this expected utility. (This field of study is known as &quot;Decision Theory&quot;, if you'd like to read more.)</p>
<p>To try to summarize, the following is a generic approach to &quot;Monte Carlo&quot; simulation-based decision making.</p>
<ol>
<li>Model the system mathematically, which means formulating an equation that describes the evolution of the system from time $t$ to $t+1$.</li>
<li>The model will possess parameters that govern the system dynamics. Try to formulate a (multivariate) prior distribution for these parameters.</li>
<li>Create a set of possibilities for rulesets that the actor in the simulation will follow.</li>
<li>Arbitrarily assign the actor a single ruleset based on the possibilities enumerated above.</li>
<li>Randomly draw a sample from the prior distribution.</li>
<li>Run the simulation with these sampled parameters and the chosen actor ruleset. The simulation will involve repeatedly stepping through time. Store the results and use our function $U$ to compute the associated utility of the &quot;possible future&quot; that we have simulated.</li>
<li>Repeat steps 5-6 sufficient times that we have confidence in our estimate of the <em>expected value</em> of utility for the actor ruleset being considered. This is known as the <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">&quot;Monte Carlo&quot;</a> approach. Note that this step can be very expensive, depending on how long it takes for each simulation to run, and how many simulations are required to reach &quot;convergence&quot;.</li>
<li>Repeat steps 5-7 for all possible actor rulesets.</li>
<li>Maximize the expected utility with respect to the ruleset. Presumably, this is the ruleset we want to follow in practice. Of course, this recommendation is only as good as the assumptions that underpin it: the simplifications made in the mathematical model, the correctness of the prior distribution, the comprehensiveness of the possibilities for rulesets, etc.</li>
</ol>
<p>All of this is somewhat abstract, so let's use my actual example to make these concepts more concrete.</p>
<h2 id="case-study">Case study</h2>
<h3 id="mathematical-model">Mathematical model</h3>
<p>As mentioned above, there are three pieces here: the actor (me), the equity package, and the stock price.</p>
<p>The dynamics of the equity package are fairly simple. Excluding some minor details like the &quot;equity cliff&quot;, at each timestep, a fraction 1/N of the equity vests. For instance, if the equity package is \$24k, and, assuming a 4 year vesting schedule, each month \$500 will vest. How this vesting translates into real money (and, in turn how that real money translates into &quot;utility&quot;) is more complicated, and will be discussed later.</p>
<p>The stock price is assumed to follow a <a href="https://en.wikipedia.org/wiki/Geometric_Brownian_motion">&quot;Geometric Brownian Motion&quot;</a> model. This essentially decomposes the rate of return into two parts, one deterministic ($\mu$) and one stochastic ($\sigma$). The former describes how the stock price would evolve in the absence of volatility (the &quot;drift&quot;), and the latter accounts for the volatility. Because one of these terms describes a stochastic process, different simulations with the <em>same</em> set of parameters ($\mu$, $\sigma$) will give different results. The governing equation is:</p>
<p>$$ S_t / S_{t-1} = \exp(\mu - \sigma^2/2 + \sigma N(0, 1)) $$</p>
<p>where $S_{t}$ is the stock price at time $t$, and $N(0, 1)$ is a unit normal distribution.</p>
<p>(Important note: I do not work in finance, and I am certainly not an expert in financial modeling. I chose this model because it seemed widely used and reasonably tractable, but the assumptions of constant variance and Gaussian processes are known to be dubious, and I'm including this caveat so that <a href="https://en.wikipedia.org/wiki/The_Black_Swan:_The_Impact_of_the_Highly_Improbable">Nassim Taleb</a> doesn't yell at me.)</p>
<h3 id="actors-rulesets">Actor's rulesets</h3>
<p>There are two main decisons the actor makes. At $t = 0$, the actor decides how to allocate his/her equity across the four asset types: cash, RSUs, ATM options, and OTM options. Then, at each $t &gt; 0$, the actor decides what to do with the equity that has vested. Let's cover each in turn.</p>
<p>Cash is very simple. Equity of amount $M_t$ vests at $t$, and the actor receives a &quot;payout&quot; of $0.9M_t$ in their bank account. (Note: The 0.9 factor is apparently related to tax reasons for the <em>company</em>. I am also ignoring taxation for the <em>individual</em>, which is a very big oversight, and, as a consequence, the numerical results below should not be taken as accurate. That being said, given the actor rulesets under consideration, the taxation of cash and RSUs is similar, so this effect is mostly irrelevant if options are not part of the allocation.)</p>
<p>RSUs are also fairly simple. At each time $t$, the actor receives a number of shares equal to $M_t / S_0$: i.e, the nominal value of the equity is divided by the stock price at the <em>grant</em> date, not at the vesting date. So, the actual value of these shares is $M_t * S_{t} / S_{0}$: the shares are worth more than cash (ignoring the discounting factor of 0.9) if the stock appreciates, and the shares are worth less if the opposite is true. I will assume that the actor is conservative, and will sell the RSUs immediately after vesting.</p>
<p>(This is not as stupid as it sounds: because RSUs are taxed on vesting, there is no real tax benefit to delaying the sale, and one can hedge against the company's stock by investing the proceeds into an index fund. In other words, we can imagine two scenarios: one in which we sell the shares and reinvest the same amount in the company (which is equivalent to holding); the other where we sell the shares and reinvest them in a diversified financial product. If the actor was given separate money for this, he/she would invariably choose the second option. So why should it be different if the actor is given money in the form of RSUs?)</p>
<p>Options are somewhat more complicated. Here I will make the somewhat questionable assumption that options are exercised at the end of the time period under consideration, with the caveat that they are not exercised if they are worthless. For ATM options, options are worth something if $S_{t} &gt; S_{0}$: the stock has to appreciate. For OTM options, options are worth something only if $S_{t} &gt; 1.5S_{0}$: the stock has to appreciate by at least 50%. To justify this extra risk relative to RSUs, 4 times as many ATM options are given as RSUs for a given equity amount, and the corresponding ratio is 8 for OTM options. The payouts end up being $4 (M / S_0) \max(S_{t_{end}} - S_0, 0)$ for ATM, and $8 (M / S_0) \max(S_{t_{end}} - 1.5 S_0, 0)$ for OTM, where $M$ is the total amount of equity (so, $NM_t$, where $N$ is the number of time steps).</p>
<p>Other rulesets are possible for options. The disadvantage of the one under consideration is that the tax bill will be enormous if the options are worth a significant amount, since the gains are concentrated in a single year instead of being more spread out. We can also imagine immediate exercise (which probably doesn't make sense, especially for OTM options), and exercise as soon as the options are worth a certain amount. These are more complicated to model, however.</p>
<p>For the initial allocation decision, I will assume a few different possibilities, summarized in the table below:</p>
<h3 id="python-code">Python code</h3>
<p>The python code to run the simulation and model the payouts is presented below. The version I present is vectorized, which makes the computation faster but also perhaps less readable. Note that, in general, it's easier to program these simulations step-by-step (advancing from $t$ to $t+1$), but this may less computationally efficient.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">SimulationRunnerVectorized</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">allocation</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="s">"""
        Initialize using parameters (mu, sigma), actor rulesets (allocation), and number of timesteps.
        The initial stock price can be set to 1 without loss of generality
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_steps</span> <span class="o">=</span> <span class="n">n_steps</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">grant_price</span> <span class="o">=</span> <span class="n">price</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">price</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">allocation</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">equity_type</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_steps</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="n">amount</span>
            <span class="k">for</span> <span class="n">equity_type</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">allocation</span><span class="p">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        
    <span class="k">def</span> <span class="nf">compute_prices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Compute stock prices for all timesteps"""</span>
        <span class="n">drift</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">n_steps</span><span class="p">,))</span>
        <span class="n">rate_of_return</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">drift</span><span class="p">)</span>
        <span class="n">prices</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">price</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">rate_of_return</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prices</span>
        
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Run simulation: compute stock prices given initial allocation; compute final payouts"""</span>
        <span class="n">prices</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">compute_prices</span><span class="p">()</span>
        <span class="n">payouts</span> <span class="o">=</span> <span class="n">calculate_payout</span><span class="p">(</span>
            <span class="n">current_price</span><span class="o">=</span><span class="n">prices</span><span class="p">,</span>
            <span class="n">grant_price</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">grant_price</span><span class="p">,</span>
            <span class="n">allocation</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">allocation</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">payouts</span>
</code></pre></div></div>
<p>Here is the code for calculating the payouts from the simulation results</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">calculate_payout</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">grant_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">allocation</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="s">"""Calculate payout by aggregating over all equity types"""</span>
    <span class="n">payout</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">payout_funcs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"cash"</span><span class="p">:</span> <span class="n">payout_cash</span><span class="p">,</span>
        <span class="s">"rsus"</span><span class="p">:</span> <span class="n">payout_rsus</span><span class="p">,</span>
        <span class="s">"atm_options"</span><span class="p">:</span> <span class="n">payout_atm_options</span><span class="p">,</span>
        <span class="s">"otm_options"</span><span class="p">:</span> <span class="n">payout_otm_options</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">equity_type</span><span class="p">,</span> <span class="n">amount</span> <span class="ow">in</span> <span class="n">allocation</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">payout</span> <span class="o">+=</span> <span class="n">payout_funcs</span><span class="p">[</span><span class="n">equity_type</span><span class="p">](</span><span class="n">prices</span><span class="p">,</span> <span class="n">grant_price</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">payout</span>

<span class="k">def</span> <span class="nf">payout_cash</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">grant_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">discount</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">amount</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">payout_rsus</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">grant_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="n">n_shares</span> <span class="o">=</span> <span class="p">(</span><span class="n">amount</span> <span class="o">/</span> <span class="n">grant_price</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n_shares</span> <span class="o">*</span> <span class="n">prices</span>

<span class="k">def</span> <span class="nf">payout_atm_options</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">grant_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">immediate_exercise</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">n_options</span> <span class="o">=</span> <span class="p">(</span><span class="n">amount</span> <span class="o">/</span> <span class="n">grant_price</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="n">immediate_exercise</span><span class="p">:</span>
        <span class="c1"># this possibility is not considered in the blog post, but is included for illustration
</span>        <span class="k">return</span> <span class="n">n_options</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">current_price</span> <span class="o">-</span> <span class="n">grant_price</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_options</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">current_price</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grant_price</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">payout_otm_options</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">grant_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">immediate_exercise</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">n_options</span> <span class="o">=</span> <span class="p">(</span><span class="n">amount</span> <span class="o">/</span> <span class="n">grant_price</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="k">if</span> <span class="n">immediate_exercise</span><span class="p">:</span>
        <span class="c1"># this possibility is not considered in the blog post, but is included for illustration
</span>        <span class="k">return</span> <span class="n">n_options</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">current_price</span> <span class="o">-</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">grant_price</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_options</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">current_price</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">grant_price</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>
<p>And, finally, here is the code to run the simulation loop (over all the different actor rulesets and parameter possibilities):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="n">ALLOCATION_RULESETS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"cash_only"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"cash"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c1"># (many rulesets omitted)
</span>    <span class="s">"even"</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">"cash"</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="s">"rsus"</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="s">"atm_options"</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span>
        <span class="s">"otm_options"</span><span class="p">:</span> <span class="mf">0.25</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">get_allocation</span><span class="p">(</span><span class="n">allocation_ruleset</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">frac_allocation</span> <span class="o">=</span> <span class="n">ALLOCATION_RULESETS</span><span class="p">[</span><span class="n">allocation_ruleset</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">equity_type</span><span class="p">:</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">amount</span> <span class="k">for</span> <span class="n">equity_type</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="n">frac_allocation</span><span class="p">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">n_steps</span> <span class="o">=</span> <span class="mi">48</span>  <span class="c1"># 4 years * 12 months
</span><span class="n">N_simulations</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># chosen arbitrarily
</span><span class="k">for</span> <span class="n">allocation_ruleset</span> <span class="ow">in</span> <span class="n">ALLOCATION_RULESETS</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>
    <span class="c1"># divide total equity amount by number of time steps
</span>    <span class="n">allocation</span> <span class="o">=</span> <span class="n">get_allocation</span><span class="p">(</span><span class="n">allocation_ruleset</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">n_steps</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">simulation_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_simulations</span><span class="p">):</span>
                <span class="n">payouts</span> <span class="o">=</span> <span class="n">SimulationRunnerVectorized</span><span class="p">(</span>
                    <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">allocation</span><span class="o">=</span><span class="n">allocation</span>
                <span class="p">).</span><span class="n">run</span><span class="p">()</span>
                <span class="n">results</span><span class="p">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s">"mu"</span><span class="p">:</span> <span class="n">mu</span><span class="p">,</span>
                    <span class="s">"sigma"</span><span class="p">:</span> <span class="n">sigma</span><span class="p">,</span>
                    <span class="s">"simulation_num"</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                    <span class="s">"strategy"</span><span class="p">:</span> <span class="n">strategy</span><span class="p">,</span>
                    <span class="s">"payout"</span><span class="p">:</span> <span class="n">payouts</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
                <span class="p">})</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</code></pre></div></div>
<p>Note: there is some tricky logic here related to time. The time increments are monthly, which means that $\mu$ and $\sigma$ should also be treated as monthly rates of return and monthly drifts, respectively. With the parameter ranges chosen above, we cover a range of <em>annual</em> rates of return from roughly -10% to 20%. The values for $\sigma$ are also arbitrary, but the minimum value is 0 (in which case the simulation is deterministic), and the maximum value is on the order of $\mu$, which should make sense intuitively.</p>
<h3 id="simulation-results">Simulation results</h3>
<p>Leaving aside the subtle matter of converting between payouts and &quot;utility&quot;, we can present the simulation results <em>for a given allocation ruleset</em> as a contour plot, with the two main parameters ($\mu$ and $\sigma$) on x- and y-axes and the payout as the third dimension (the color/contour level). As an example, the &quot;cash only&quot; ruleset leads to a flat plot with 0.9 for all values of the parameters, since the cash payout does not depend on the stock price. (Note: we are also ignoring effects of inflation here.). More interesting are plots for some of the other allocation rulesets (note: I have multiplied by $\mu$ and $\sigma$ by 12, which roughly converts them to annual quantities)</p>
<h4 id="allocation-to-rsus-only">Allocation to RSUs only</h4>
<p><img src="/assets/img/rsus_only.png" alt="RSUs only contour plot" title="RSUs only contour plot" /></p>
<h4 id="allocation-to-atm-options-only">Allocation to ATM options only</h4>
<p><img src="/assets/img/atm_only.png" alt="ATM only contour plot" title="ATM only contour plot" /></p>
<h4 id="allocation-to-otm-options-only">Allocation to OTM options only</h4>
<p><img src="/assets/img/otm_only.png" alt="OTM only contour plot" title="OTM only contour plot" /></p>
<p>We can draw a few conclusions:</p>
<ol>
<li>For the rates of return being simulated, the OTM options are strictly inferior to the ATM options. They become superior only for higher annual rates of return (&gt;15%). This makes sense, given that the total appreciation over 4 years has to be &gt;50% for these options to be worth anything, let alone better than the other equity types. (Using a longer time horizon, such as ten years, which is the typical expiration date for options, would change these conclusions.)</li>
<li>RSUs are relatively unaffected by volatility ($\sigma$), but increased volatility actually helps options moderately. This is not too surprising, since options are a one-sided bet: you make money if the stock price goes up a lot, but don't lose money if it goes down a lot. So, for a low rate of return, increased volatility increases the likelihood of <em>both</em> the former outcome and the latter outcome, resulting in a higher expected payout.</li>
<li>Since the payouts are far more sensitive to $\mu$ than to $\sigma$, we can also plot these results in a more comprehensible line plot format, where we fix $\sigma$ (here, at $0.2/12$) and plot the results against $\mu$:</li>
</ol>
<p><img src="/assets/img/payout_line_plot.png" alt="Payout line plot" title="Payout line plot" /></p>
<p>This plot provides a useful graphical summary of the different growth assumptions under which the various equity types make sense. It also shows how mixing options with RSUs and/or cash (the &quot;default&quot; and &quot;even&quot; allocations) can provide a compromise that still provides some payout under negative or low stock price growth, while providing substantial upside under high stock price growth.</p>
<h3 id="prior-probabilities-and-utility-functions">Prior probabilities and utility functions</h3>
<p>Arguably, the most difficult part of this exercise is not implementing the simulation, but generating a sensible prior distribution. Most tech stocks are very young, and therefore there may not be sufficient historical data to inform a prior. Moreover, assuming that future stock price movements will follow historical trends is always a dangerous assumption.</p>
<p>I don't have any great advice to provide here, but I think a wide Gaussian, centered at some positive rate of return that roughly equals the historical market return (say, S&amp;P 500 or Nasdaq), seems reasonable. This choice avoids being overly optimistic, comprises a wide range of scenarios (negative, low, and high growth) and does not rely too heavily on thin historical data.</p>
<p>(Note: I am also only considering $\mu$ here. Estimating $\sigma$ is even more challenging, although, fortunately, it does not affect the results too much.)</p>
<p>The utility function is also highly subjective. In my case, I am fairly risk-averse, and therefore my utility function is shaped concave downwards (see <a href="https://en.wikipedia.org/wiki/Risk_aversion">here</a> for examples). In contrast, others may view equity as &quot;house money&quot;, and only care if they strike it rich and not care otherwise. This would be &quot;risk-seeking&quot; behavior. Ultimately, this is a personal decision that depends on your own financial situation and feelings towards money, and there is no single &quot;right&quot; answer.</p>
<p>It is also not obvious whether we should be looking at the expected value at all, particularly if we are risk averse. Perhaps we'd like to adopt a <a href="https://en.wikipedia.org/wiki/Minimax">&quot;maximin&quot;</a> approach, where we maximize the utility associated with a low-quantile outcome, such as the 10th or 25th percentile. This should be straightforward using the machinery we developed above, since we have effectively generated the entire payout probability distribution. The likely outcome, with respect to decision making, is that the optimal allocation shifts more towards cash/RSUs (safer assets) and away from options (riskier assets)</p>
<h2 id="summary-and-conclusions">Summary and conclusions</h2>
<p>To conclude:</p>
<ol>
<li>Monte Carlo simulations can be a powerful tool for decision making, when combined with a function that takes us from &quot;outcomes&quot; to &quot;utility&quot;.</li>
<li>These simulations have several interrelated pieces: a parametric equation describing how to move from time $t$ to $t+1$; a prior probability distribution for these parameters; and a ruleset followed by the actor (if relevant). By running simulations from the same initial conditions $N$ times, where $N$ is sufficiently large, we can generate the complete probability distribution for the simulation outcomes.</li>
<li>We applied this framework to a specific problem: how to allocate equity across 4 different asset types to maximize the expected utility associated with the payout. Using a geometric Brownian motion model for the stock price, and some (slick?) Python code, we generated vaguely pretty plots that showed how payouts change with the volatility ($\sigma$) and the rate of return ($\mu$). Unsurprisingly, the four different asset types behave very differently in negative, low, and high growth regimes, and their behavior can be smoothed out by blending different asset types together.</li>
<li>The most difficult part of this exercise lies in the subjective/unknowable aspects: the prior probability distributions and the utility functions.</li>
<li>There were many dubious assumptions made (neglecting taxation, assuming a geometric Brownian motion model for stock prices, settling on a simple-to-code but suboptimal strategy for exercising options, etc.), so this should not be taken as a final word on this problem. Indeed, the purpose was more to show an example of the Monte Carlo simulation technique than to decide on an &quot;optimal&quot; allocation ruleset for me.</li>
</ol>
<p>(For those who are curious, I plan to put the vast majority of my equity into RSUs; given my risk aversion, this decision makes more sense than the default allocation (75% RSUs, 25% ATM options), and RSUs are superior to cash even under somewhat pessimistic growth assumptions. That being said, I took the analysis above as more of a guide than anything else; I did not try to &quot;argmax&quot; my way to a decision.)</p>

  </div><a class="u-url" href="/blog/a-random-walk-down-wall-street/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Varun&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Varun&#39;s blog</li><li><a class="u-email" href="mailto:varun.rajan@hey.com">varun.rajan@hey.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/varunprajan"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">varunprajan</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Data science + data engineering posts</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
